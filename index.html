<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Toetsomgeving passend zonder scroll</title>
  <style>
    /* Basis, geen scroll en nette rendering */
    * { box-sizing: border-box }
    html, body { height: 100%; margin: 0 }
    body {
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #f2f5f8;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /*
      #stage is de omhulling om jouw bestaande toetsomgeving
      Plak jouw volledige oude HTML binnen #stage, niets binnenin hoeft te veranderen
      We schalen #stage zodat alles altijd volledig zichtbaar is, zonder scroll
    */
    #stage {
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: top left;
      will-change: transform;
      /* breedte en hoogte worden dynamisch gezet na het meten */
    }

    /* Optioneel, beter contrast voor afbeeldingen op borden met hoge dichtheid */
    img { image-rendering: -webkit-optimize-contrast }
  </style>
</head>
<body>

  <!--
    PLAK HIERONDER JOUW OUDE TOETSOMGEVING
    Voorbeeld: kopieer de volledige body-inhoud van je oude pagina en zet die hier tussen <div id="stage"> en </div>
    Wil je handmatig een vaste ontwerpmaat forceren, voeg dan data-attributen toe
    bijvoorbeeld: <div id="stage" data-base-width="1280" data-base-height="720">
  -->
  <div id="stage">
    <!-- JOUW BESTAANDE HTML KOMT HIER -->
  </div>

  <script>
    ;(() => {
      const stage = document.getElementById('stage')

      // Bovenlimiet voor extreem grote schermen zoals 4K borden
      const MAX_SCALE = 2.0

      // Fallback ontwerpmaat als meten nul oplevert of als je deze expliciet instelt via data-attributen
      const DEFAULT_BASE_WIDTH  = parseInt(stage.getAttribute('data-base-width')  || '1280', 10)
      const DEFAULT_BASE_HEIGHT = parseInt(stage.getAttribute('data-base-height') || '720', 10)

      let baseW = 0
      let baseH = 0
      let ro = null
      let raf = null

      function measureBaseSize() {
        // Bewaar huidige stijl, maak tijdelijk ongeschaald om te meten
        const prevTransform = stage.style.transform
        const prevWidth = stage.style.width
        const prevHeight = stage.style.height

        stage.style.transform = 'none'
        stage.style.width = 'auto'
        stage.style.height = 'auto'

        // Meet natuurlijke afmeting van jouw bestaande layout
        const w = Math.max(stage.scrollWidth, stage.offsetWidth, stage.clientWidth) || 0
        const h = Math.max(stage.scrollHeight, stage.offsetHeight, stage.clientHeight) || 0

        baseW = w > 0 ? w : DEFAULT_BASE_WIDTH
        baseH = h > 0 ? h : DEFAULT_BASE_HEIGHT

        // Zet vaste basismaat vast zodat schalen voorspelbaar wordt
        stage.style.width = baseW + 'px'
        stage.style.height = baseH + 'px'
        stage.style.transform = prevTransform

        // Zorg dat het element op het midden blijft uitgelijnd
        stage.style.left = '50%'
        stage.style.top = '50%'
      }

      function scaleToFit() {
        if (!baseW || !baseH) measureBaseSize()

        const vw = Math.max(document.documentElement.clientWidth,  window.innerWidth  || 0)
        const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)

        // Schaal zodat alles past binnen het zichtbare venster
        let s = Math.min(vw / baseW, vh / baseH)
        if (Number.isFinite(MAX_SCALE)) s = Math.min(s, MAX_SCALE)
        // Geen onderlimiet, zo blijft het altijd passend, ook op kleinere schermen

        stage.style.transform = `translate(-50%, -50%) scale(${s})`
      }

      function queueScale() {
        if (raf) return
        raf = requestAnimationFrame(() => {
          raf = null
          scaleToFit()
        })
      }

      function onLoadInit() {
        // Eerst meten, daarna schalen
        measureBaseSize()
        scaleToFit()

        // Resize en rotatie
        window.addEventListener('resize', queueScale, { passive: true })
        window.addEventListener('orientationchange', queueScale, { passive: true })

        // Schaal opnieuw als lettertypen geladen zijn
        if (document.fonts && document.fonts.ready) {
          document.fonts.ready.then(queueScale).catch(() => {})
        }

        // Schaal wanneer afbeeldingen klaar zijn
        stage.querySelectorAll('img').forEach(img => {
          if (!img.complete) {
            img.addEventListener('load', queueScale, { once: true })
            img.addEventListener('error', queueScale, { once: true })
          }
        })

        // Observeer latere DOM wijzigingen binnen #stage, bijvoorbeeld dynamische inhoud of paginawissels
        if ('ResizeObserver' in window) {
          ro = new ResizeObserver(() => queueScale())
          ro.observe(stage)
        }
      }

      if (document.readyState === 'complete') {
        onLoadInit()
      } else {
        window.addEventListener('load', onLoadInit, { passive: true })
      }
    })()
  </script>
</body>
</html>